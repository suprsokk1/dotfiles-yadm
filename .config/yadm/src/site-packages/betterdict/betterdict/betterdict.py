#!/usr/bin/env python3

"""
TODO parse lists
TODO parse lists containing BetterDict
NOTE add support for arithmetic operations and '|'
REVIEW add support for bitwise operations?
"""

import json

from subprocess import run, Popen, PIPE, DEVNULL



class BetterDict(object):
    delimiter = '.'

    def __init__(self, *args, **kwargs):
        self.__delimiter__ = self.delimiter

        if 'delimiter' in self.__dict__:
            del self.__dict__['delimiter']

        self.__update__ = self.update
        self.__update__(*args, **kwargs)

    def __getattr__(self, name):
        new = self.__class__()
        setattr(self, name, new)
        return new

    def __setattr__(self, name, value): # WORKING
        self.__dict__.update({
            name:self.__class__(value)
            if type(value) == 'dict' else
            value
        })

    # def __setattr__(self, name, value):
    #     T = type(value)

    #     if self.__has__(name):
    #         old_value = self.__getitem__(name)
    #         t = type(old_value)

    #         if t is dict:
    #             pass
    #         elif t is list:

    #         elif t is str:
    #             pass


        # if T is dict:
        #     self.__dict__.update({name: self.__class__(value)})

        # if T is list:
        #     self.__dict__.update({name: value})

        # if T is str:
        #     self.__dict__.update({name: value})



    def __setitem__(self, *args):
        setattr(self, *args)

    def __getitem__(self, name):
        """TODO raise error if key is missing"""
        item, *rest = name.split(self.__delimiter__, 1)
        out = self.__dict__[item]

        return out.__getitem__(rest[0]) if rest else out

    def __repr__(self):
        types = ['str', 'str', self.__class__.__name__, 'int']
        data = self.__dict__.copy()
        data = {k:v
                for k,v in data.items()
                if v.__class__.__name__ in types
                and k not in ['__delimiter__']}

        return data.__str__()

    def __has__(self, name):
        return self.__dict__.get(name, False)

    def get(self, key, *args):
        if args:
            fallback, *rest = args
        return self.__getattr__(key) if self.__has__(key) else fallback

    def has(self, key):
        return self.__has__(key)

    def update(self, *args, **kwargs):
        for k,v in (_ for _d in args for _ in {**kwargs,**_d}.items()):
            if type(v) is dict:
                self[k] = self.__class__(v)
            else:
                self[k] = v

    def from_command(self, command_string):
        res = (
            run(command_string.split(), shell=False, capture_output=True)
            .stdout
            .decode()
        )
        self.from_json(res)

    def from_json(self, json_string):
        assert type(json_string) is str
        try:
            self.update(json.loads(json_string))
            return True
        except Exception:
            return False

    def to_json(self, **kwargs):
        data = eval(self.__str__())
        return json.dumps(data, **kwargs)

    def to_dict(self):
        """FIXME ugly eval hack"""
        return eval(self.__str__())

    def to_env(self):
        """TODO."""

    def to_ini(self):
        """TODO."""

    def to_toml(self):
        """TODO."""

    def to_yaml(self):
        """TODO round trip support; anchors"""

    def gron(self):
        """TODO."""
