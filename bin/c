#!/bin/python
# -*- coding: utf-8 -*-

import os
import pathlib
import re
import subprocess as S
import sys
from functools import lru_cache
from os.path import exists, getmtime, join
from pathlib import Path
from subprocess import DEVNULL, PIPE, Popen
from subprocess import run as Run
from tempfile import NamedTemporaryFile

try:
    import fire
except ModuleNotFoundError:
    os.system("pip install --user fire")
    import fire

try:
    from jinja2 import BaseLoader, Template, TemplateNotFound
except ModuleNotFoundError:
    os.system("pip install --user fire")
    from jinja2 import BaseLoader, Template, TemplateNotFound

try:
    import psutil
except ModuleNotFoundError:
    os.system("pip install --user psutil")
    import psutil

try:
    from rich import print
except ModuleNotFoundError:
    os.system("pip install --user rich")
    from rich import print


parent = PARENT = psutil.Process(os.getppid())

EMPTY_STRING = ''

EMACS = PARENT.name() == 'emacs'
ROFI = PARENT.name() == 'rofi'
DMENU = PARENT.name() == 'dmenu'
FZF = PARENT.name() == 'fzf'
VIM = PARENT.name() == 'vim'
ZSH = PARENT.name() == 'zsh'
BASH = PARENT.name() == 'bash'
SH = PARENT.name() == 'sh'
INCROND = PARENT.name() == 'incrond'
CROND = PARENT.name() == 'incrond'
TMUX = PARENT.name() == 'tmux'

CRON = CROND or INCROND
SHELL = SH or ZSH or BASH
EDITOR = EMACS or VIM
LAUNCHER = MENU = ROFI or DMENU or FZF

HOME = os.getenv("HOME")
USER = os.getenv("USER")

TTY = sys.stdin.isatty()

SYSTEMD_SOCKET_UNIT = """
# {{ name }}.socket
[Unit]
Description = {{ desc }}

[Socket]
ListenStream = {{ tcp_port }}
Accept = yes

[Install]
WantedBy = sockets.target
"""

SYSTEMD_SERVICE_UNIT = """
# {{ name }}@.service
[Unit]
Description={{ name }} server service

[Service]
ExecStart=%h/bin/{{ name }} poc --systemd
StandardInput=socket
"""

icons = """
\\u{f115}
\\u{e5fc}
\\u{f016}
\\u{e615}
"""

NEWLINE = NL = "\n"


class CliBase:
    """To use as base for cli apps based on google-fire."""

    def list(self):
        return "list"

    def add(self, subcommand):
        return f"add: {subcommand}"

    def set(self, subcommand):
        return f"set: {subcommand}"

    def edit(self, name):
        editor = os.getenv("EDITOR", os.getenv("VISUAL", "/usr/bin/vim"))
        S.Popen([self.edit_format])

    def remove(self, subcommand):
        return f"remove: {subcommand}"

    def __init__(self):
        self.__class__.__name__
        self.edit_format = "/run/user/%s/{name}" % os.getenv("UID")

class CliConfigure(object):
    """"""
    pass

class CliEnvironment(object):
    """TODO manage environment variables"""
    template = """
    {% for %}
    """

class CliList(object):
    """All the lists."""
    pass

class CliInstall(object):
    """Install using recipes for cli tools"""
    pass

class CliBootstrap(object):
    """Quick local setup"""
    pass

class Tmux(object):
    pass


class CliFzf(CliBase):
    """TODO Manage password manager."""

class CliPass(CliBase):
    """TODO Manage password manager."""

class CliIncron(CliBase):
    """TODO Manage incrontab."""

class CliCron(CliBase):
    """TODO Manage crontab."""

class CliDotfiles(CliBase):
    """TODO Manage user dotfiles."""

class CliAlias(CliBase):
    """TODO Manage user shell aliases."""

class CliContainers(CliBase):
    """TODO Generate dynamic menu for applications like fzf or rofi."""

class CliOrgTodos(CliBase):
    """TODO Generate dynamic menu for applications like fzf or rofi."""

class CliHealthChecks(CliBase):
    """TODO"""

class CliRofiWrapper:
    """TODO Generate dynamic menu for applications like fzf or rofi."""

class CliDoctor:
    """TODO
    - DOOM emacs
    """

class CliConfig(CliBase):
    """TODO Doctor for doom ...etc."""

class CliDictLoader:
    """TODO"""


def systemd_escape(self, fname, systemd=False, install=False) -> str:
    dest = (Path.home() / 'Projects' / 'site' / 'templates')
    home = os.getenv('HOME')
    path = Path(fname)
    hexed = hexify(
        path.absolute().__str__().replace(home, '~'), *'-~/'
    ).replace('0x', '\\x')
    new = (dest / hexed)

    if systemd and install:
        new.write_text(path.read_text())
        return new.absolute().__str__()

    elif systemd:
        return hexed

def call_emacs_daemon(sexp):
    elisp = '(progn'
    elisp += '(switch-to-buffer (window-buffer))'
    elisp += '{}'
    elisp += ')'

    cmd = elisp.format(sexp)
    call(["emacsclient" , "--eval", cmd])


def pipe_to_emacs():
    """TODO swich to temp buffer"""

    elisp = '(progn'
    elisp += '(switch-to-buffer (window-buffer))'
    elisp += '(split-window-below)'
    elisp += '(switch-to-buffer (get-buffer-create "*stdin*"))'
    elisp += '{}'
    elisp += '(mark-page)'
    elisp += ')'

    with NamedTemporaryFile('w+') as tmp:
        print(sys.stdin.read(), file=tmp)
        cmd = elisp.format(f'(insert-file "{tmp.name}")')
        call(["emacsclient" , "--eval", cmd])
        return tmp.name


def pipe_to_tmux():
    """TODO tmux"""


class EasyPath(pathlib.Path):
    def __rshift__(left, right):
        """Append to file"""
        lt = type(left)
        rt = type(right)

        with right.open('a') as fd:
            fd.write(left.read() if lt is str else right)

    def __gt__(left, right):
        """Append to file"""
        lt = type(left)
        rt = type(right)

        with right.open('w') as fd:
            fd.write(left.read() if lt is str else right)


def catch(func):
    def _catch(*args, **kwargs):
        ret = ""
        try:
            ret = func(*args, **kwargs)
        except Exception as e:
            print(e, file=sys.stderr)

        return ret

    return _catch


def paths(func):
    def _catch(*args, **kwargs):
        ret = func(*args, **kwargs)
        lines = ret.splitlines()

        if ret > 1:
            return [_ for _ in lines if Path(_).exists()]
        elif type(ret) is str:
            return ret
        else:
            return ""

    return _catch


def filters(*filters):
    def _inner(func):
        def _wrapper(*args, **kwargs):
            ret = func(*args, **kwargs)
            if 'git_status' in filters:
                # ret = [_.split(" ", 1)[1] for _ in ret]
                ret = [_[3:] for _ in ret]
            return ret
        return _wrapper
    return _inner


@catch
def decode(func):
    def _wrapper(*args, **kwargs):
        p = func(*args, **kwargs)

        if p.returncode == 0:
            print(p.stdout)
            return p
            # return lines if len(lines) > 1 else out.decode()
        else:
            return err.decode()

    return _wrapper


def call(*args) -> None:
    with Popen(*args) as p:
        p.communicate()


@filters('git_status')
@decode
def run(*args, **kwargs) -> None:
    with Popen([*args], **{**dict(stdout=PIPE, stderr=PIPE), **kwargs}) as p:
        p.communicate()
        return p


@filters('git_status')
def run(*args, **kwargs) -> None:
    with Popen([*args], **{**dict(stdout=PIPE, stderr=PIPE), **kwargs}) as p:
        p.communicate()
        if p.returncode == 0:
            # print(dir(p))
            return p.communicate()[0].decode().splitlines()



class Cli(object):
    """Do.. stuff."""

    def parent(self) -> None:
        """FIXME """
        return parent.name

    def pipe(self) -> None:
        if SHELL:
            return pipe_to_emacs()

        if EDITOR:
            # if emacs is parent
           return pipe_to_tmux()

    def rofi(self, *items, menu=False) -> None:
        """TODO rofi"""
        return

    r = rofi                    # alias

    def preview(self, *items) -> None:
        """fzf preview"""

        return parent.name

    def debug(self):
        """debug"""
        cmd = Command('yadm config debug.enable', bool=True)
        # logger.debug(cmd)
        res = cmd.run()

        return res

    def notify(self, topic, *msg) -> None:
        """Send notification."""
        n = Notify(topic, ' '.join(msg))
        n.send()

    n = msg = notify


    def escape(self, fname, systemd=False, install=False) -> str:
        if systemd:
            res = run("", shell=True, capture_output=True)
            return res[0].decode()


    def menu(self, *args):
        """for debugging."""

        return                  # FIXME
        submenu = Menu()

        wallpapers = Command('fd',
                             max_depth=3,
                             e=['jpg','png','webm'])

        yaml = Command('fd . ~',
                       max_depth=3, e=['yml', 'yaml'],
                       a=[])

        fd01 = Command('fd',
                       max_depth=3,
                       type='file',
                       color='never',
                       absolute_path=None,
                       unrestricted=None)

        fd02 = Command('fd',
                       max_depth=3, type='file',
                       color='never',
                       absolute_path=None)

        submenu.add(MenuItem('Files', fd02))

        submenu.select(*args)

        return submenu.show()

    def j2(self) -> str:
        """
        Render Jinja2 templates
        ---

        """

        return Template.render()

    def jcat(self, *json_files) -> str:
        import json

        python_objects = []
        for json_file in json_files:
            with open(json_file, "r") as f:
                python_objects.append(json.load(f))

        return json.dumps(python_objects, indent=4)

    def callback(self) -> None:
        """Run hooks for application executing this command."""

        if CRON:
            call(f"""tmux source-file {HOME}/""".split())
            return


    # def zsh(self, name, widget=False, plugin=False, force=False) -> str:
    #     """Run hooks for application executing this command."""
    #     if widget:
    #         _in = sys.stdin.read()
    #         return ' '.join(_in.split('\n'))

    #     elif plugin:
    #         p = Path.home() / ".oh-my-zsh" / "custom" / "plugins" / name /  f"{name}.plugin.zsh"
    #         relpath = p.relative_to(Path.home())
    #         p.parent.mkdir(exist_ok=True, parents=True)
    #         head = "# ~/{}".format(relpath)
    #         _in = sys.stdin.read()

    #         if force:
    #             pass
    #         elif not TTY:
    #             pass
    #         else:
    #             return "File exists "

    #         p.write_text(head + "\n")

    #         with p.open('a') as fd:
    #             fd.write(_in)

    #         return p.read_text()


    def reload(self, all=True, tmux=False, sway=False, doom=False, systemd=True) -> str:
        """Reload config(s)"""
        _all = not any((tmux, sway, doom))
        del all

        prefix = "" if not systemd else "/usr/bin/systemd-run --user"

        if tmux or _all:
            call(f"""{prefix} tmux source-file {HOME}/.tmux.conf""".split())

        if sway or _all:
            call(f"""{prefix} sway reload""")

        if doom:
            os.system(f"""doom sync""")
            # call(f"""doom sync""")

        return ' '.join(_in.split('\n'))

    yadm_env = dict(GIT_DIR=f"{HOME}/.local/share/yadm/repo.git", GIT_WORK_TREE=HOME)

    def yadm(self, status=False):
        ret = run('git', 'status', '--porcelain=v1', env=self.yadm_env)
        return ret

    def status(self, _all=True, yadm=False, git=False) -> list:
        if yadm:
            ret = run('git', 'status', '--porcelain=v1', env=self.yadm_env)

            return ret

        elif git:

            return run('git', 'status', '-0')

    def list(self, _all=True, yadm=False, docker=False) -> list:
        if yadm:
            return run('yadm', 'ls-files').splitlines()
        elif docker:
            return run('docker', 'container', 'list', '--all').splitlines()
        else:
            return list(range(10))

    def emacs_super_dot_callback(self, *data):
        """WIP."""
        call_emacs_daemon(f"""{data}""")

    def grep(self, *args, **kwargs):
        S.Popen("grep -wo -- 0".split(), env={})

        # S.Popen("grep -wo -- 0".split(), stdin=sys.stdin, stdout=sys.stdout, env={})

    def col(self, n, **kwargs):
        """Print column(s) 'n' from stdin. Default is 1"""
        S.Popen("grep -wo -- 0".split(), env={})

        # TODO ip shell command like

    def configure(self, action, fname):
        """TODO Edit files """
        return Path(fname)

    def shims(self):
        """TODO Manage symlinks in ~/.shims"""
        shims = Path.home() / '.shims'

    def edit(self, action, fname):
        """TODO Edit files """
        return Path(fname)

    def dot(self, list=True):
        """
        TODO
        - short for dotfiles
        - print all dotfiles if no argument is given
        """
        if list:
            S.Popen(['yadm', 'ls-files'])

    # def fzf(self, preview=False):
    #     """
    #     fzf helper
    #     ---
    #     good defaults
    #     - dont take up entire screen/term
    #     - dont show preview
    #     - binding info. in header
    #     """
    #     pattern = r''''''

    def clean(self, backup=True):
        """TODO Clean home folder"""

    # def reload(self):
    #     """TODO Verify and reload changed config files."""
    #     pattern = r''''''

    def run(self):
        """TODO Run command. Even if not in path."""
        pattern = r''''''

    def esc(self):
        """TODO"""
        # sys.stdout.

    def re(self, jq=False, tmux=False):
        """TODO agnostic parsing of stdin as json """
        def e(char):
            return rf'\x{ord(char):x}'
        def r(*_range):
            return r'{%s}' % (','.join(map(str, _range)))

        p_1 = e("^") + e("[") + r(2) + r'\d{2}'
        # return  p_1
        p_2 = rf'''(?P<ansi>{p_1})'''
        pattern = rf'''{p_2}|^(?P<ps1>.*[ ][~#][ ])?(?P<line>(?:\s*)(?P<word>\S+).*)$'''
        c_regex2json = [f"{HOME}/go/bin/regex2json", pattern]
        c_jq = [f"/usr/bin/jq", "--slurp"]
        c_tmux = [f"/usr/bin/tmux","capture-pane", "-C", "-p"]

        kwargs = dict(
            stdin=sys.stdin if any((sys.stdin.isatty(), tmux)) else S.Popen(c_jq, env={}, stdin=S.PIPE).stdout,
            stdout=sys.stdout if jq else S.Popen(c_jq, env={}, stdout=S.PIPE).stdin,
        )

        proc = S.Popen(c_regex2json, env={}, **kwargs)
        execution_results = proc.communicate()

    def vpn(self, *state):
        """TODO vpn 'on' or 'off'"""
        state = "unknown"

        return state

    def c(self, *cols):
        """???"""
        fallback = '''{print $1}'''
        multi = '''{print %s}''' % (','.join([rf'${col}' for col in cols]))
        S.Popen([f"/bin/awk", fallback if not cols else multi], env={})

    def helper(self, app, action, *optional):
        rg = rg_cmd_builder(*optional)
        fzf = fzf_cmd_builder()

        if app == 'fzf' and  action in ['command', 'default']:
            S.Popen(rg)

        elif app == 'fzf' and action in ['preview']:
            return optional[0].split(':')[0]

        elif app == 'fzf' and action in  ['run']:
            S.Popen(fzf)

    def t(self):
        """***DEBUGGING***"""
        return fzf_cmd_builder()

    def tt(self):
        """***DEBUGGING***"""
        S.Popen(rg_cmd_builder())

    def ttt(self):
        """***DEBUGGING***"""
        return rg_cmd_builder()

    def __init__(self):
        # self.menuitem = Cli()
        # self.alias = CliAlias()
        # self.dotfiles = CliDotfiles()
        # self.bootstrap = CliBootstrap()
        # self.bind = CliBindings()
        # self.zsh = CliZsh()
        # self.fzf = CliFzf()
        self.default = CliDefault()

        # aliases
        # self.pa = self.parent
        # self.p = self.pipe

"""
TODO load json/yaml/toml as command
"""

def cmd_builder(cmd, *args, shell_escape=False, **kwargs):

    def _f(k, v):
        symbol = type(v) is bool

        return '--{key}{sep}{val}'.format(
            key=k.replace('_', '-'),
            sep='=' if not symbol else EMPTY_STRING,
            val=v if not symbol else EMPTY_STRING,
        )

    longopts = [
        _f(option, value)
        for option, values in kwargs.items()
        for value in (values if type(values) is list else [values])
    ]

    shortopts = list(args)

    return [cmd] + shortopts + longopts


def fzf_cmd_builder():
        mod = 'ctrl'
        preview = f'{mod}-v'
        refresh = f'{mod}-r'
        selectall = f'{mod}-a'
        toggleall = f'{mod}-t'

        beg, end = '{}'
        middle = r'p'

        sep = r'|'              # preview separator
        sep = r''               # preview separator

        def _b(*args):
            middle, *rest = args if args else ['']
            return beg + middle + end

        cmd = cmd_builder(
            'fzf',
            query=f'foobar',
            # preview=f'{__file__} helper fzf preview {beg}{end}',
            preview=f'( command cut -d: -f1 | head | command xargs bat --color=always ) <<< ' + _b() + ' || echo ' + _b(),
            bind=[
                f'{selectall}:select-all',
                f'{toggleall}:toggle-all',
                # f'{preview}:preview:({__file__} helper fzf preview {beg}{middle}{end})',
                f'change:reload:{__file__} helper fzf default {_b("p")} || true',
            ],
            header=f"{selectall}:Select all {sep} {preview}:Preview {sep} {refresh}:Refresh",
            ansi=True,
            layout='reverse',
            height=30,
        )

        return cmd


def rg_cmd_builder(*args):
    rg = cmd_builder(
        'rg',
        'foobarbaz',
        color='always',
        column=True,
        line_number=True,
        no_heading=True,
        smart_case=True,
    )

    return rg


def j2(template, data: dict):
    return Template(template, data)


def install(content: str, dest: str, **kwargs):
    dest = Path() / dest
    assert not dest.is_file() or kwargs.get('force', False)
    dest.write_text(content)

@lru_cache
def hexify(string: str, *chars):
    if chars:
      char, *rest = chars
      args = (char, {'/': '-'}.get(char, hex(ord(char))))

      return hexify(string.replace(*args), *rest)

    else:

      return string


class CliDefault:
    def __init__(self):
        pass

class CliDefaultFzf:
    def __init__(self):
        pass

class CliFzf(CliBase):
    def __init__(self):
        pass

class CliZsh:
    def __init__(self):
        self.plugin = CliZshPlugin()


class CliZshPlugin(CliBase):
    def create(self, name: str, force=False) -> str:
        p = Path.home() / ".oh-my-zsh" / "custom" / "plugins" / name /  f"{name}.plugin.zsh"
        relpath = p.relative_to(Path.home())
        p.parent.mkdir(exist_ok=True, parents=True)
        head = "# ~/{}".format(relpath)
        _in = sys.stdin.read()

        if force:
            pass
        elif not TTY:
            pass
        else:
            return "File exists "

        p.write_text(head + "\n")

        with p.open('a') as fd:
            fd.write(_in)

        return p.read_text()


class CliBindings(object):
    """TODO Manage key bindings for ...
    - Emacs
    - tmux
    - zsh
    - bash
    """


def main():
    try:
        fire.Fire(Cli)
    except Exception as e:
        print(e)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt as i:
        exit(1)
    except ModuleNotFoundError as m:
        pass
