# .zshrc -*- mode: sh -*-

# force tmux to truncate lines
setterm --linewrap off

# NOTE ðŸ’¡alias/override command options; f.ex. alias grep.only-matching='func or command' override grep --only-matching
# FIXME tmux completion and maybe others
# TODO disable bell
# TODO disable all predefined static dirs
hash -d yadm=$HOME/.config/yadm
hash -d run="${XDG_RUNTIME_DIR:-/run/user/${EUID:-$(id -u)}}"
hash -d config="${XDG_CONFIG_HOME:-$HOME/.config}"
hash -d ram=$HOMErun
hash -d temp=$HOMErun
hash -d fonts=$HOME/.local/share/fonts
hash -d autorun=$HOME/.config/autorun
hash -d desktop=$HOME/.local/share/applications

ZSH=~/.oh-my-zsh
ZSH_THEME="af-magic"
ZSH_THEME="simple"

read regex_url <<'REGEX'
^(((ht|f)tp(s?))\://)?(www.|[a-zA-Z].)[a-zA-Z0-9\-\.]+\.(com|edu|gov|mil|net|org|biz|info|name|museum|us|ca|uk)(\:[0-9]+)*(/($|[a-zA-Z0-9\.\,\;\?\'\\\+&%\$#\=~_\-]+))*$
REGEX

# plugins-=(pipenv)
plugins+=(zsh-autosuggestions)
# plugins+=(h)                    # breaks zsh-autosuggestions?
# plugins+=(git)
plugins+=(direnv)
plugins+=(fzf)

FZF_DEFAULT_OPTS="--layout=reverse --height=7"
FZF_DEFAULT_COMMAND=$HOME/bin/,

PROMPT_COMMAND=
# PROMPT_COMMAND+="`# TODO`_refresh_completion &>/dev/null"
PROMPT_COMMAND+='; . ~/.functions'
PROMPT_COMMAND+='; . ~/.aliases'
PROMPT_COMMAND+='; tmux set @p ${PWD}' # tmux pane title
PROMPT_COMMAND+='; test -d ${PWD}/.git && '

if ! test -d ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
then git clone https://github.com/zsh-users/zsh-autosuggestions $_
fi

for ITEM in aliases functions parameters; do
    function -list--$ITEM {
        eval "print -rl -- \${(k)${funcstack##*-}}"
    }
done

# activate oh-my-zsh
if [[ -s $ZSH/oh-my-zsh.sh  ]]; then
. $ZSH/oh-my-zsh.sh
fi

# detect tmux popup window
if [[ $TMUX ]]; then
  if [[ $TMUX_PANE ]]; then

    ## normal pane

    # when active tmux will display
    PROMPT="${PROMPT//git_prompt_info/true}"

  else

    ## popup

    if false; then
      tmux source-file ~/.config/tmux/tmux.conf
      __tmux_menu # TODO
    fi
  fi
fi

# set -x
if command -v crontab &>/dev/null
then : <<.syntax; { envsubst | crontab - &>/dev/null; } <<'CRONTAB'
# m h w m y
  * * * * * commandline
.syntax

PATH=${HOME}/bin:${PATH}
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/${EUID}/bus
WAYLAND_DISPLAY=${WAYLAND_DISPLAY}

*/5 * * * *
CRONTAB
fi

if command -v incrontab &>/dev/null
then : <<.syntax; { envsubst | incrontab - &>/dev/null; } <<'INCRONTAB'
$$   dollar sign
$@   watched filesystem path (see above)
$#   event-related file name
$%   event flags (textually)
$&   event flags (numerically)
.syntax

PATH=${HOME}/bin:${PATH}
DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/${EUID}/bus
WAYLAND_DISPLAY=${WAYLAND_DISPLAY}

${HOME}/.local/share/fonts/   IN_ALL_EVENTS,recursive=false    , $%,"$@/$#"
${HOME}/Downloads/            IN_ALL_EVENTS,recursive=false    , $%,"$@/$#"
${HOME}/git/org/roam/         IN_CREATE,recursive=false        env -C ${HOME}/git/org gh repo sync
${HOME}/watch/                IN_ALL_EVENTS,recursive=false    /usr/bin/notify-send --expire-time 5000 $# $%
INCRONTAB
fi

if false; then
source <(when jc --zsh-comp)
fi

# this must be the last file to load
set - zsh-syntax-highlighting
if [[ -s ~/src/"$1"/"$1".zsh ]]; then
source ~/src/"$1"/"$1".zsh
fi; shift

#
## completion
##

_vpn() {
    reply=( on off up down 0 1 )
}
compctl -K {_,}vpn

:<<COMPLETION_EXAMPLES
$ zstyle :completion:<function>:<completer>:<command>:<argument>:<tag>
COMPLETION_EXAMPLES

zsh_cache_dir="${XDG_CACHE_HOME:-/run/user/${EUID:-$(id -u)}}/zsh/.zcompcache"
zstyle ':completion:*' cache-path "$zsh_cache_dir"
zstyle ':completion:*' use-cache on
zstyle ':completion:*' squeeze-slashes true

alias _nmap='_subnets'

#
## Emacs default 'M-l'
##

bindkey "^[l" down-case-word

#
## Insert last commands output
## https://github.com/rothgar/mastering-zsh/blob/master/docs/helpers/widgets.md
##
zmodload -i zsh/parameter

insert-last-command-output() {
  LBUFFER+="$(eval $history[$((HISTCMD-1))])"
}
zle -N insert-last-command-output
bindkey "^Q^L" insert-last-command-output


#
## TODO replace word at point
##

fzf-replace-word() {
  fzf --preview "echo $words[-1]"
}
zle -N fzf-replace-word


#
## Clipboard
##

paste-clipboard-wayland() {
  LBUFFER+="$(eval wl-paste)"
}

paste-clipboard-x() {
  LBUFFER+="$(eval xclip -out -selection clipboard)"
}
zle -N paste-clipboard-wayland
zle -N paste-clipboard-x
if [[ $WAYLAND_DISPLAY ]]; then
bindkey "^[y" paste-clipboard-wayland
else
bindkey "^[y" paste-clipboard-x
fi


#
## FIXME Pretty print JSON
##

pretty-print-json() {
  LBUFFER="$(eval jq <<< \"$json\")"
}
zle -N pretty-print-json
bindkey "^Q^J" pretty-print-json

foo() {
  case ${#LBUFFER} in
    0)
        tmux display-message "Nothing to do.."
      ;;
    *)
      tmux split -H "cat"
  esac
}
zle -N foo
bindkey "^[i" foo


#
## FIXME In case homebrew break Python deps
##

if false; then
old_path="$PATH"
path=( ${(m)path:#*brew*} )
export PATH
fi

bar() {
  {
    tmux next-layout
  } &>/dev/null
  LBUFFER=${LBUFFER}
}
zle -N bar

bindkey "^[]" bar
